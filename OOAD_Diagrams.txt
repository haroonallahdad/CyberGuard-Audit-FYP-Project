I have reviewed the `app.py` and `mainpage.html` files to understand the project's functionality and architecture. Based on this analysis, I will provide detailed descriptions for the requested OOAD diagrams. Since I cannot generate graphical diagrams, I will describe them in a textual format, outlining the components and their relationships.

Here are the detailed OOAD-based diagrams for the CyberGuard Penetration Testing Platform:

---

### 1. Use Case Diagram

This diagram illustrates the high-level interactions between the main actors and the system's primary functionalities.

**Actors:**
*   **Security Analyst (Primary Actor):** The main user of the platform, interacting with the web interface.
*   **System (CyberGuard Platform):** Represents the entire automated penetration testing platform, encompassing both frontend and backend logic.
*   **OWASP ZAP API:** An external web application security scanner.
*   **Google Gemini API:** An external AI service for chatbot functionality.
*   **File System:** The local storage where reports and uploaded files reside.

**Use Cases (Grouped by Functionality):**

*   **User Interface & Navigation:**
    *   Navigate to Home Page
    *   Navigate to Reconnaissance & Dorking Page
    *   Navigate to Device Scanning Page
    *   Navigate to Web Application Scanning Page
    *   Navigate to Web Scan Reports Page
    *   Navigate to Privacy Policy Page
    *   Navigate to Documentation Page
    *   Navigate to API Reference Page
    *   Navigate to Support Page
    *   Navigate to Terms of Service Page

*   **Reconnaissance & Dorking:**
    *   Perform OSINT Username Search
    *   Retrieve Phone Contact Information

*   **Device Scanning:**
    *   Perform Port Scan
    *   Perform Network Discovery

*   **Web Application Scanning:**
    *   Initiate Content Discovery (Spider Scan)
    *   Perform Vulnerability Scan (Active Scan)
    *   Reset ZAP Session

*   **Reporting & File Management (Gallery):**
    *   Upload Audit Document
    *   View Gallery Item (Audit Document or Report)
    *   Download Gallery Item (Audit Document or Report)
    *   Delete Gallery Item (Audit Document or Report)
    *   Generate ZAP Native Report
    *   Generate Dark Custom Report
    *   Generate Light Custom Report (6-Risk Report)

*   **AI Assistance:**
    *   Interact with Chatbot

**Relationships:**

*   **Security Analyst** `uses` all "User Interface & Navigation," "Reconnaissance & Dorking," "Device Scanning," "Web Application Scanning," "Reporting & File Management," and "AI Assistance" use cases.
*   **System** `includes` or `extends` various internal processes and interacts with external systems to fulfill the user's requests.
*   **Web Application Scanning** use cases (`Initiate Content Discovery`, `Perform Vulnerability Scan`, `Reset ZAP Session`) `interact with` **OWASP ZAP API**.
*   **AI Assistance** use case (`Interact with Chatbot`) `interacts with` **Google Gemini API**.
*   **Reporting & File Management** use cases (`Upload Audit Document`, `View/Download/Delete Gallery Item`, `Generate Reports`) `interact with` **File System**.
*   **Reconnaissance & Dorking** and **Device Scanning** use cases implicitly interact with external network resources (e.g., websites for OSINT, target IPs for scanning) via the **System**.

---

### 2. Full-Body Use Case Diagram: Perform Vulnerability Scan (Active Scan)

This detailed use case describes the flow for initiating and monitoring an active web application vulnerability scan, as it is a core functionality.

**Use Case Name:** Perform Vulnerability Scan (Active Scan)

**Actors:** Security Analyst, CyberGuard Platform (Frontend & Backend), OWASP ZAP API

**Goal:** To thoroughly scan a target web application for vulnerabilities and obtain detailed alerts and a report.

**Preconditions:**
1.  The CyberGuard backend Flask application is running.
2.  OWASP ZAP is running in daemon mode and accessible by the backend (typically on `127.0.0.1:8080`).
3.  The Security Analyst has provided a valid target URL in the "Web Application Scanning" section.

**Main Flow:**
1.  **Security Analyst** navigates to the "Web Application Scanning" page.
2.  **Security Analyst** enters a `target_url` (e.g., `https://example.com`) into the designated input field.
3.  **Security Analyst** clicks the "Perform Vulnerability Scan" button.
4.  **CyberGuard Platform (Frontend)** disables all web scan-related buttons (`spider-scan-btn`, `active-scan-btn`, `reset-zap-session-btn`, `toggle-report-options-btn`) and displays a loading message with a spinner in the `web-scan-results` area.
5.  **CyberGuard Platform (Frontend)** sends an asynchronous API request to the **Backend** endpoint `/api/web/access_zap_url` with the `target_url`.
6.  **CyberGuard Platform (Backend)** receives the request and makes an API call to **OWASP ZAP API** (`zap.urlopen(target_url)`) to ensure ZAP has accessed the URL and built its site tree.
7.  **OWASP ZAP API** processes the URL access.
8.  **CyberGuard Platform (Backend)** receives a success response from ZAP and sends a success response back to the **Frontend**.
9.  **CyberGuard Platform (Frontend)** then sends a second asynchronous API request to the **Backend** endpoint `/api/web/active_scan` with the `target_url`.
10. **CyberGuard Platform (Backend)** receives the request and makes an API call to **OWASP ZAP API** (`zap.ascan.scan(url=target_url)`) to initiate the active scan.
11. **OWASP ZAP API** starts the active scan and returns a `scan_id`.
12. **CyberGuard Platform (Backend)** stores the `scan_id` (e.g., in `app.config` or `active_scans` dictionary) and responds with success, including the `scan_id`.
13. **CyberGuard Platform (Frontend)** receives the `scan_id` and starts a polling interval (e.g., every 5 seconds) to the **Backend** endpoint `/api/web/scan_status/<scan_id>`.
14. **CyberGuard Platform (Frontend)** updates the UI with a progress bar and "Active scan in progress: X%" message based on polling responses.
15. **CyberGuard Platform (Backend)**, upon receiving a status request, queries **OWASP ZAP API** (`zap.ascan.status(scan_id)`) for the current progress and `zap.core.alerts()` for any detected vulnerabilities.
16. **OWASP ZAP API** returns the scan progress (0-100%) and a list of alerts.
17. **CyberGuard Platform (Backend)** processes the ZAP response and sends it back to the **Frontend**.
18. **CyberGuard Platform (Frontend)** continues polling until the scan status is "completed" or "error."
19. If the scan status is "completed":
    *   **CyberGuard Platform (Frontend)** displays "Active scan for 'target_url' completed successfully!" along with a summary of vulnerabilities (e.g., Critical, High, Medium, Low, Informational counts) and detailed alerts.
    *   **CyberGuard Platform (Frontend)** stores the `detailed_alerts` and `vulnerability_summary` in `lastScanResults` for subsequent report generation.
    *   **CyberGuard Platform (Frontend)** re-enables all web scan-related buttons and specifically enables the "Generate Report" button and its dropdown options.
    *   **CyberGuard Platform (Frontend)** shows a "ZAP Active Scan completed!" success toast notification.
20. If the scan status is "error" or "timed_out":
    *   **CyberGuard Platform (Frontend)** displays an appropriate error message (e.g., "Scan error: [message]" or "Scan timed out").
    *   **CyberGuard Platform (Frontend)** re-enables all web scan-related buttons but keeps report generation buttons disabled (as no valid results are available).
    *   **CyberGuard Platform (Frontend)** shows an error toast notification.

**Alternative Flows:**

*   **AF1: Invalid Target URL:**
    1.  (Main Flow Step 2) Security Analyst enters an invalid or empty URL.
    2.  **CyberGuard Platform (Frontend)** displays a validation error message (e.g., "Please enter a target URL for the active scan.").
    3.  Use Case ends.

*   **AF2: ZAP API Not Connected/Error during Initiation:**
    1.  (Main Flow Step 6 or 10) **CyberGuard Platform (Backend)** fails to connect to **OWASP ZAP API** or ZAP returns an error during `access_zap_url` or `active_scan` initiation.
    2.  **CyberGuard Platform (Backend)** logs the connection/API error.
    3.  **CyberGuard Platform (Backend)** responds with an error status (e.g., 500, 503, 504).
    4.  **CyberGuard Platform (Frontend)** displays an error message (e.g., "Could not connect to ZAP API. Ensure ZAP is running in daemon mode." or "Error initiating scan: [message]").
    5.  Use Case ends.

*   **AF3: Scan Polling Error:**
    1.  (Main Flow Step 15) During polling, **CyberGuard Platform (Backend)** encounters an error communicating with **OWASP ZAP API** or ZAP itself.
    2.  **CyberGuard Platform (Backend)** responds with an error status.
    3.  **CyberGuard Platform (Frontend)** stops polling, displays an error message (e.g., "Error during scan status check: [message]"), and re-enables buttons, disabling report generation.
    4.  Use Case ends.

**Postconditions:**
*   If successful: The target web application has been scanned, detailed vulnerability alerts are available in the frontend (`lastScanResults`), and report generation options are enabled.
*   If unsuccessful: An error message is displayed, and no valid scan results are available for reporting.

---

### 3. ERD (Entity-Relationship Diagram)

The project primarily deals with files and their associated metadata, stored on the file system and in a JSON file. There isn't a complex relational database for users or other entities, so the ERD focuses on the stored documents and reports.

**Entities:**

*   **File/Report:** Represents any document (e.g., PDF, image) manually uploaded by the user or an HTML report generated by the system.
    *   **Attributes:**
        *   `fileName` (Primary Key, String): Unique name of the file (e.g., `Advanced Scan Connected Pakistan_Nessus Report_3a7b4efb.pdf`, `zap_native_report_20250726_114332.html`). This is the actual filename on disk.
        *   `fileUrl` (String): The URL path to access the file via the Flask backend (e.g., `http://127.0.0.1:5000/uploads/filename.pdf`).
        *   `fileType` (String): MIME type of the file (e.g., `application/pdf`, `text/html`, `image/jpeg`).
        *   `source` (String): Indicates the origin of the file (`upload` for manual uploads, `zap_report` for automated reports).
        *   `mtime` (Timestamp): Last modification time of the file on the file system (used for sorting, not directly exposed in frontend output).
        *   `timestamp` (Timestamp): Time when the file/report was added/generated (stored in metadata, primarily for display).

*   **Metadata:** Represents additional descriptive information for a `File/Report` entry. This data is stored in `file_metadata.json`.
    *   **Attributes:**
        *   `fileName` (Primary Key, String): Foreign key linking to the `File/Report` entity.
        *   `title` (String): User-provided or system-generated title (e.g., "Q1 2024 Audit Policy", "ZAP Native Report: https://example.com").
        *   `description` (String): User-provided or system-generated brief description.
        *   `highest_risk` (String, Optional): For `zap_report` source items, indicates the highest risk level found in the report (e.g., 'critical', 'high', 'informational', 'none').

**Relationships:**

*   **File/Report** `has` **Metadata** (1-to-1 relationship).
    *   Each physical file or generated report (represented by its `fileName`) can have one corresponding `Metadata` entry in the `file_metadata.json` file. The `fileName` attribute serves as the linking key between the actual file and its metadata.

**Diagram Representation (Textual):**

```
+-----------------+       +-----------------+
|   File/Report   |       |     Metadata    |
+-----------------+       +-----------------+
| PK fileName     |-------| PK fileName     | (FK to File/Report)
| fileUrl         | 1   1 | title           |
| fileType        |       | description     |
| source          |       | highest_risk    | (Optional, for reports)
| mtime           |       | timestamp       |
| timestamp       |       +-----------------+
+-----------------+
```

---

### 4. Class Diagram (Python Backend)

This diagram focuses on the key Python classes and modules in the backend and their relationships, as identified across `app.py`, `device_scanner.py`, `osint_checker.py`, and `phone_tracker.py`.

**Classes/Modules:**

*   **Flask.Flask** (`app.py`): The main Flask application instance.
    *   **Attributes:** `config`, `template_folder`, `logger`, `extensions` (for SocketIO), `active_scans`.
    *   **Methods:** `route()`, `after_request()`, `run()`, `_guess_mime_type()`, `load_metadata()`, `save_metadata()`.
    *   **Relationships:**
        *   `uses` `Flask.request`, `Flask.jsonify`, `Flask.send_from_directory`, `Flask.render_template`, `Flask.current_app`.
        *   `uses` `werkzeug.utils.secure_filename`.
        *   `uses` `flask_cors.CORS`.
        *   `uses` `flask_socketio.SocketIO`.
        *   `uses` `zapv2.ZAPv2`.
        *   `uses` `osint_checker` (module).
        *   `uses` `phone_tracker` (module).
        *   `uses` `subprocess` (for `device_scanner.py`).
        *   `uses` `requests` (for Gemini API and ZAP direct calls).
        *   `uses` `phonenumbers` (indirectly via `phone_tracker`).
        *   `uses` `re`, `os`, `sys`, `json`, `time`, `uuid`, `html`, `logging`, `threading`, `datetime`, `collections.defaultdict`, `urllib.parse`.

*   **Flask.request** (from `flask`): Represents the incoming HTTP request.
    *   **Attributes:** `get_json()`, `files`, `form`, `remote_addr`.

*   **Flask.jsonify** (from `flask`): Utility for creating JSON responses.

*   **Flask.send_from_directory** (from `flask`): Utility for serving files from a directory.

*   **Flask.render_template** (from `flask`): Utility for rendering Jinja2 templates.

*   **Flask.current_app** (from `flask`): Proxy to the current application context.

*   **werkzeug.utils.secure_filename** (from `werkzeug.utils`): Secures filenames for safe storage.

*   **flask_cors.CORS** (from `flask_cors`): Flask extension for handling CORS headers.

*   **flask_socketio.SocketIO** (from `flask_socketio`): Enables WebSocket communication for real-time updates.
    *   **Methods:** `emit()`, `run()`.

*   **zapv2.ZAPv2** (from `zapv2`): Python client for the OWASP ZAP API.
    *   **Attributes:** `apikey`, `proxies`.
    *   **Methods:** `urlopen()`, `spider.scan()`, `spider.status()`, `spider.results()`, `ascan.scan()`, `ascan.status()`, `core.alerts()`, `core.htmlreport()`.

*   **osint_checker** (Module `osint_checker.py`): Handles OSINT username checks.
    *   **Functions:** `check_username(username, socketio=None)`.
    *   **Relationships:** `uses` `requests`, `sys`, `json`. `Communicates with` `socketio` for progress updates.

*   **phone_tracker** (Module `phone_tracker.py`): Handles phone number tracking.
    *   **Functions:** `track_phone_number(phone_number_str, socketio=None)`.
    *   **Relationships:** `uses` `phonenumbers`, `sys`, `json`, `datetime`. `Communicates with` `socketio` for progress updates.

*   **device_scanner** (Module `device_scanner.py`): Handles network and device scanning.
    *   **Functions:** `is_valid_ipv4()`, `is_valid_hostname()`, `scan_port()`, `perform_port_scan()`, `discover_network_hosts()`.
    *   **Relationships:** `uses` `socket`, `json`, `sys`, `argparse`, `subprocess`, `re`, `time`. (Note: `app.py` executes this module as a subprocess, not directly imports its functions).

**Relationships (Simplified Textual Representation):**

```
+---------------------+       +---------------------+       +---------------------+
|      Flask.Flask    |       |    flask_socketio.  |       |      zapv2.ZAPv2    |
|      (app.py)       |       |       SocketIO      |       |      (ZAP API)      |
|---------------------|       |---------------------|       |---------------------|
| - config            |<>-----| + emit()            |       | - apikey            |
| - template_folder   |       | + run()             |       | - proxies           |
| - logger            |       +---------------------+       |---------------------|
| - extensions        |                                     | + urlopen()         |
| - active_scans      |                                     | + spider.scan()     |
|---------------------|                                     | + ascan.scan()      |
| + route()           |                                     | + core.alerts()     |
| + after_request()   |                                     | ...                 |
| + run()             |                                     +---------------------+
| + _guess_mime_type()|
| + load_metadata()   |
| + save_metadata()   |
| ... (API endpoints) |
+---------------------+
        |
        | Uses/Orchestrates
        v
+---------------------+       +---------------------+       +---------------------+
| osint_checker       |       | phone_tracker       |       | device_scanner      |
| (osint_checker.py)  |       | (phone_tracker.py)  |       | (device_scanner.py) |
|---------------------|       |---------------------|       |---------------------|
| + check_username()  |       | + track_phone_number()|       | + perform_port_scan()|
+---------------------+       +---------------------+       | + discover_network_hosts()|
        ^                               ^                     | ...                 |
        | Communicates via SocketIO     |                     +---------------------+
        +-------------------------------+
```

---

### 5. System Diagram (Component/Deployment Diagram)

This diagram illustrates the overall architecture of the CyberGuard platform, showing how different components are deployed and interact across the user's machine and the backend server.

**Components:**

*   **User Interface (Frontend):**
    *   **Technologies:** HTML5, CSS3 (Tailwind CSS, Custom CSS), JavaScript (ES6+).
    *   **Libraries:** Marked.js (for Markdown rendering in chatbot).
    *   **Deployment:** Runs directly in the user's web browser.
    *   **Responsibilities:** Renders the web pages, handles user input, displays scan results and reports, manages navigation, and communicates with the Backend via HTTP/HTTPS and WebSockets.

*   **Backend Server (Flask Application):**
    *   **Technologies:** Python 3, Flask framework.
    *   **Core File:** `app.py`.
    *   **Deployment:** Runs as a web server process (e.g., `http://127.0.0.1:5000`).
    *   **Responsibilities:** Exposes RESTful API endpoints for all functionalities, manages file uploads and storage, orchestrates calls to internal security modules and external APIs, handles report generation, and provides real-time updates via Flask-SocketIO.

*   **Internal Security Modules:**
    *   **OSINT Checker:** `osint_checker.py` (Python script).
        *   **Responsibilities:** Performs open-source intelligence gathering for usernames across various platforms.
    *   **Phone Tracker:** `phone_tracker.py` (Python script).
        *   **Responsibilities:** Parses phone numbers and retrieves publicly available information (simulated associated accounts).
    *   **Device Scanner:** `device_scanner.py` (Python script).
        *   **Responsibilities:** Executes network discovery (ping scans) and port scanning on target IPs/networks.
    *   **Deployment:** These are Python scripts located within the backend directory, executed by the `app.py` either by direct import or as subprocesses.

*   **File Storage:**
    *   **Uploads Folder:** `First Attempt/backend/uploads/`
        *   **Contents:** Stores user-uploaded audit documents, images, and other files.
    *   **Reports Folder:** `First Attempt/backend/reports/`
        *   **Contents:** Stores generated HTML security reports (ZAP Native, Dark Custom, Light Custom).
    *   **Metadata File:** `First Attempt/backend/uploads/file_metadata.json`
        *   **Contents:** JSON file storing metadata (title, description, highest risk) for items in both `uploads` and `reports` folders.
    *   **Deployment:** These are directories and files on the local file system where the backend application is running.

*   **External APIs:**
    *   **OWASP ZAP (Zed Attack Proxy):**
        *   **Type:** External web application security testing tool.
        *   **Deployment:** Expected to be running in daemon mode (e.g., `http://127.0.0.1:8080`) on the same machine or a reachable network location.
        *   **Interaction:** The Backend (specifically `app.py`) communicates with ZAP via its Python API client (`zapv2`) over HTTP/HTTPS for initiating scans, retrieving status, and generating reports.
    *   **Google Gemini API:**
        *   **Type:** External AI service.
        *   **Deployment:** Cloud-based service provided by Google.
        *   **Interaction:** The Backend (`app.py`) makes HTTP POST requests to the Gemini API for chatbot interactions, sending user messages and chat history, and receiving AI-generated responses.

**Interactions/Deployment Flow:**

```
+---------------------------------------------------------------------------------+
|                                 User's Machine                                  |
|                                                                                 |
|  +---------------------+                                                        |
|  |   User Interface    |                                                        |
|  |     (Frontend)      |                                                        |
|  |---------------------|                                                        |
|  | - HTML, CSS, JS     |                                                        |
|  | - User Interaction  |                                                        |
|  | - Displays Results  |                                                        |
|  +---------------------+                                                        |
|          |                                                                      |
|          | HTTP/HTTPS (API Requests)                                            |
|          | WebSocket (Real-time progress updates via SocketIO)                  |
|          v                                                                      |
+---------------------------------------------------------------------------------+
          |
          | (Network Boundary - e.g., localhost or remote server)
          v
+---------------------------------------------------------------------------------+
|                                 Backend Server                                  |
|                                                                                 |
|  +---------------------+                                                        |
|  |   Backend Server    |                                                        |
|  |  (Flask Application)|                                                        |
|  |---------------------|                                                        |
|  | - app.py            |                                                        |
|  | - RESTful API       |                                                        |
|  | - SocketIO Server   |                                                        |
|  | - Orchestrates Tools|                                                        |
|  +---------------------+                                                        |
|    |       |       |                                                            |
|    |       |       | (Executes Python scripts as subprocesses or imports)       |
|    |       |       +---------------------------------------------------------+  |
|    |       |                                                                 |  |
|    |       +---------------------------------------------------------+       |  |
|    |                                                                 |       |  |
|    v                                                                 v       v  |
|  +---------------------+   +---------------------+   +---------------------+  |
|  | Internal Security   |   | Internal Security   |   | Internal Security   |  |
|  | Module: OSINT       |   | Module: Phone       |   | Module: Device      |  |
|  |  Checker            |   |  Tracker            |   |  Scanner            |  |
|  |---------------------|   |---------------------|   |---------------------|  |
|  | - osint_checker.py  |   | - phone_tracker.py  |   | - device_scanner.py |  |
|  +---------------------+   +---------------------+   +---------------------+  |
|                                                                                 |
|  +---------------------+                                                        |
|  |    File Storage     |                                                        |
|  |---------------------|                                                        |
|  | - uploads/          |                                                        |
|  | - reports/          |                                                        |
|  | - file_metadata.json|                                                        |
|  +---------------------+                                                        |
+---------------------------------------------------------------------------------+
          |                                     ^
          | HTTP/HTTPS (API Calls)              | HTTP/HTTPS (API Calls)
          v                                     |
+---------------------+                   +---------------------+
|   OWASP ZAP API     |                   | Google Gemini API   |
|  (External Tool)    |                   | (External Service)  |
|---------------------|                   |---------------------|
| - Web App Scanner   |                   | - AI Chatbot        |
| - Vulnerability DB  |                   | - Natural Language  |
+---------------------+                   +---------------------+
```

---

I believe this comprehensive breakdown addresses your request for detailed OOAD diagrams for the entire project, covering its functionalities and interactions between all components.

Please let me know if you have any further questions or require additional details on any specific aspect.
